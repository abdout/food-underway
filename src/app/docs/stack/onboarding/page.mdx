## Onboarding (Personas & Patterns)

Design onboarding flows for all personas using consistent, composable patterns. No deadlines—iterate steadily and document as we go.

### Personas

- Owner: creates school, sets plan, invites admins
- Admin: configures classes/subjects, invites teachers and parents
- Teacher: joins class, marks attendance, posts announcements
- Parent: verifies phone/email, views child data
- Student: optional self-onboarding (invite-based)

### Core building blocks

- UI: shadcn/ui components (Input, Button, Select, Dialog, Sheet)
- Forms: React Hook Form + `@hookform/resolvers/zod`
- Validation: Zod schemas collocated per feature
- Actions: Next.js Server Actions with `"use server"`
- Feedback: Sonner toasts for success/error
- Auth: Auth.js patterns already present in repo

### Folder pattern (abc example)

```
src/components/abc/
  actions.ts       # server actions (createSchool, inviteUser)
  validation.ts    # zod schemas
  types.ts         # shared types
  form.tsx         # RHF forms composed from shadcn/ui
  content.tsx      # page content composed from forms
```

### Zod + RHF example

```tsx
import { z } from "zod"
import { useForm } from "react-hook-form"
import { zodResolver } from "@hookform/resolvers/zod"
import { Input } from "@/components/ui/input"
import { Button } from "@/components/ui/button"
import { toast } from "sonner"

const schema = z.object({
  schoolName: z.string().min(2),
  email: z.string().email(),
})

export function CreateSchoolForm({ onSubmit }: { onSubmit: (v: z.infer<typeof schema>) => Promise<void> }) {
  const form = useForm<z.infer<typeof schema>>({ resolver: zodResolver(schema) })

  return (
    <form
      onSubmit={form.handleSubmit(async (v) => {
        await onSubmit(v)
        toast.success("School created")
      })}
      className="space-y-3"
    >
      <Input placeholder="School name" {...form.register("schoolName")} />
      <Input type="email" placeholder="Email" {...form.register("email")} />
      <Button type="submit">Create</Button>
    </form>
  )
}
```

### Server Action pattern

```ts
'use server'
import { z } from 'zod'
import { db } from '@/lib/db'

const createSchool = z.object({ schoolName: z.string().min(2), email: z.string().email() })

export async function createSchoolAction(values: z.infer<typeof createSchool>) {
  // validate again on the server
  const parsed = createSchool.parse(values)
  await db.school.create({ data: { name: parsed.schoolName, email: parsed.email } })
  // return minimal data for client feedback
  return { ok: true }
}
```

### Flow orchestration

1. Owner: Create school → choose plan (trial by default) → invite admin
2. Admin: Configure classes/subjects → invite teachers/parents
3. Teacher: Join class → mark attendance → post first announcement
4. Parent: Accept invite → verify → view child

### UX notes

- Use sheets/dialogs to segment steps; keep forms minimal
- Show toasts for feedback; inline errors from Zod
- RTL/LTR: ensure labels/placeholders mirrored appropriately

### Checklists

- Form + schema + action exist and are wired
- Success/error toasts present
- Redirects or revalidatePath used after mutations
- Tests/manual steps documented in PR


